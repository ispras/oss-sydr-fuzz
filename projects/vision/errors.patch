diff --git a/aten/src/ATen/core/ivalue_inl.h b/aten/src/ATen/core/ivalue_inl.h
index 6c524da40e..51c12440bd 100644
--- a/aten/src/ATen/core/ivalue_inl.h
+++ b/aten/src/ATen/core/ivalue_inl.h
@@ -498,6 +498,9 @@ struct TORCH_API TupleElements {
       TORCH_CHECK(idx < inlineSize_, "TupleElements: invalid index Index = ", idx, "; Length = ", inlineSize_);
       return elementsInline_[idx];
     } else {
+      if (idx > elementsVector_.size()) {
+          TORCH_CHECK(false, "patch check for out_of_range #1");
+      }    
       return elementsVector_.at(idx);
     }
   }
diff --git a/aten/src/ATen/native/quantized/cpu/conv_serialization.h b/aten/src/ATen/native/quantized/cpu/conv_serialization.h
index cf5c04977b..657f1eafda 100644
--- a/aten/src/ATen/native/quantized/cpu/conv_serialization.h
+++ b/aten/src/ATen/native/quantized/cpu/conv_serialization.h
@@ -306,6 +306,7 @@ c10::intrusive_ptr<ConvPackedParamsBase<kSpatialDim>> deserialize_conv(
   }
   for (const auto i : c10::irange(kSpatialDim)) {
     (void)i; // Suppress unused variable
+    TORCH_INTERNAL_ASSERT(idx < config_vals.size(), "patched fix of out_of_range #2");
     output_padding.emplace_back(config_vals.at(idx));
     idx++;
   }
diff --git a/torch/csrc/jit/frontend/source_range.cpp b/torch/csrc/jit/frontend/source_range.cpp
index cd4f6fcb00..b977382280 100644
--- a/torch/csrc/jit/frontend/source_range.cpp
+++ b/torch/csrc/jit/frontend/source_range.cpp
@@ -90,6 +90,9 @@ C10_EXPORT void SourceRange::print_with_context(
   // determine CONTEXT line range
   size_t begin_line = start(); // beginning of lines to highlight
   size_t end_line = range_end;
+  if (begin_line > str.size()) {
+    return;
+  }
   while (begin_line > 0 && str[begin_line - 1] != '\n')
     --begin_line;
   while (end_line < str.size() && str[end_line] != '\n')
diff --git a/torch/csrc/jit/serialization/unpickler.cpp b/torch/csrc/jit/serialization/unpickler.cpp
index 391849ace7..a507c38d2d 100644
--- a/torch/csrc/jit/serialization/unpickler.cpp
+++ b/torch/csrc/jit/serialization/unpickler.cpp
@@ -329,6 +333,7 @@ PickleOpCode Unpickler::readInstruction() {
       stack_.emplace_back(readFloat());
       break;
     case PickleOpCode::TUPLE: {
+      TORCH_CHECK(!marks_.empty(), "patch fix sigsegv #1");
       size_t start = marks_.back();
       marks_.pop_back();
       std::vector<IValue> elements;
@@ -385,7 +390,9 @@ PickleOpCode Unpickler::readInstruction() {
           c10::impl::GenericDict(AnyType::get(), AnyType::get()));
       break;
     case PickleOpCode::APPENDS: {
+      TORCH_CHECK(!marks_.empty(), "patch fix sigsegv #2");
       size_t start = marks_.back();
+      TORCH_CHECK(start > 1 && (start - 1) < stack_.size(), "patched fix out_of_range #4");
       auto list_ivalue = stack_.at(start - 1);
       readList(list_ivalue);
     } break;
@@ -395,6 +402,7 @@ PickleOpCode Unpickler::readInstruction() {
       stack_.push_back(std::move(list_ivalue));
     } break;
     case PickleOpCode::DICT: {
+      TORCH_CHECK(!marks_.empty(), "patch fix sigsegv #3");
       size_t start = marks_.back();
       marks_.pop_back();
       auto dict = c10::impl::GenericDict(AnyType::get(), AnyType::get());
@@ -405,8 +413,10 @@ PickleOpCode Unpickler::readInstruction() {
       stack_.emplace_back(std::move(dict));
     } break;
     case PickleOpCode::SETITEMS: {
+      TORCH_CHECK(!marks_.empty(), "patch fix sigsegv #4");
       size_t start = marks_.back();
       marks_.pop_back();
+      TORCH_CHECK(start > 1 && (start - 1) < stack_.size(), "patched fix out_of_range #5");
       auto dict = stack_.at(start - 1).toGenericDict();
       for (size_t i = start; i < stack_.size(); i += 2) {
         dict.insert_or_assign(stack_[i], stack_[i + 1]);
@@ -441,6 +451,7 @@ PickleOpCode Unpickler::readInstruction() {
       size_t idx = stack_.back().toInt();
       stack_.pop_back();
       // stack is: <functor_arg>
+      TORCH_CHECK(idx < globals_.size(), "patched fix out_of_range #6");
       globals_.at(idx)();
     } break;
     case PickleOpCode::BINPERSID: {
@@ -907,6 +918,7 @@ std::string Unpickler::readBytes(size_t length) {
 // Pop all the list items off of the stack and append them to the list at
 // the corresponding MARK
 void Unpickler::readList(IValue list_ivalue) {
+  TORCH_CHECK(!marks_.empty(), "patch fix sigsegv #6");
   size_t start = marks_.back();
   marks_.pop_back();
   auto num_elements = stack_.size() - start;
